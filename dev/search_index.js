var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [QuantumAlgebra]","category":"page"},{"location":"interface/#QuantumAlgebra.Avac","page":"Interface","title":"QuantumAlgebra.Avac","text":"Avac(A::OpSum), vacA(A::OpSum)\n\nSimplify operator by assuming it is applied to the vacuum from the left or right, respectively. To be precise, Avac(A) returns A such that A0 = A0, while vacA(A) does the same for 0A.\n\n\n\n\n\n","category":"function"},{"location":"interface/#QuantumAlgebra.BosonCreate-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.BosonCreate","text":"BosonCreate(name,inds): represent bosonic creation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.BosonDestroy-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.BosonDestroy","text":"BosonDestroy(name,inds): represent bosonic annihilation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.CorrPerm_isless-Tuple{Tuple, Tuple}","page":"Interface","title":"QuantumAlgebra.CorrPerm_isless","text":"CorrPerm_isless(a,b)\n\nisless for Tuples of Tuples representing products of Corr (see above) of a permutation of operators. E.g., ((1,3),(2,)) represents <A1 A3>C <A2>C. It is assumed that the total number of operators in a and b is equal, i.e., that sum(length.(a)) == sum(length.(b)).\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.CorrTup_isless-Union{Tuple{M}, Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, M}}}} where {N, M}","page":"Interface","title":"QuantumAlgebra.CorrTup_isless","text":"CorrTup_isless(a,b)\n\nisless for Tuples of integers that represent Corr of sorted Operators (with n representing An such that n<m == An<Am). (n,m,...) ≡ Corr(AnAm...). Defined in such a way that the same order is obtained as with BaseOperator objects\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.FermionCreate-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.FermionCreate","text":"FermionCreate(name,inds): represent fermionic creation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.FermionDestroy-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.FermionDestroy","text":"FermionDestroy(name,inds): represent fermionic annihilation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.TLSCreate-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.TLSCreate","text":"TLSCreate(name,inds): represent TLS creation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.TLSDestroy-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.TLSDestroy","text":"TLSDestroy(name,inds): represent TLS annihilation operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.TLSx-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.TLSx","text":"TLSx(name,inds): represent TLS x operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.TLSy-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.TLSy","text":"TLSy(name,inds): represent TLS y operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.TLSz-Tuple{Any, Vararg{Any, N} where N}","page":"Interface","title":"QuantumAlgebra.TLSz","text":"TLSz(name,inds): represent TLS z operator name_inds\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.expval2corrs_inds-Tuple{Int64}","page":"Interface","title":"QuantumAlgebra.expval2corrs_inds","text":"expval2corrs_inds(N::Int)\n\nfor N operators, create an array of tuples of tuples that represents the terms in a sum of products of correlators. Each tuple corresponds to a sum term, see CorrTup_isless and CorrPerm_isless for details of the format. The returned array and terms are sorted such that if the N operators are sorted, the represented expression is also sorted with the conventions of the QuantumAlgebra package. This allows to directly return a normal-ordered form.\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.expval_as_corrs-Tuple{QuantumAlgebra.OpSum}","page":"Interface","title":"QuantumAlgebra.expval_as_corrs","text":"expval_as_corrs(expr::Operator)\n\nTake an expression expr=A B C + D E... and write its expectation value in terms of correlations A_c B_c AB_c ABC_c ldots. Note that A_c = A.\n\nE.g., expval_as_corrs(adag(:n)*a(:n)) returns a^dagger_n a_n_c + a^dagger_n_c a_n_c (which is equal to a^dagger_n a_n), while expval_as_corrs(adag(:n)*a(:m)*a(:n)) returns langle a_n^dagger a_m a_n rangle_c + langle a_n^dagger rangle_c langle a_m rangle_c langle a_n rangle_c + langle a_n^dagger rangle_c langle a_m a_n rangle_c + langle a_m rangle_c langle a_n^dagger a_n rangle_c + langle a_n rangle_c langle a_n^dagger a_m rangle_c.\n\nSee also: expval, corr\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.extindices-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.extindices","text":"extindices(A) return externally visible indices of an expression\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.symmetric_index_nums-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.symmetric_index_nums","text":"symmetric_index_nums(A) return sequence of numbers of exchange-symmetric indices\n\n\n\n\n\n","category":"method"},{"location":"interface/#QuantumAlgebra.vacA","page":"Interface","title":"QuantumAlgebra.vacA","text":"Avac(A::OpSum), vacA(A::OpSum)\n\nSimplify operator by assuming it is applied to the vacuum from the left or right, respectively. To be precise, Avac(A) returns A such that A0 = A0, while vacA(A) does the same for 0A.\n\n\n\n\n\n","category":"function"},{"location":"interface/#QuantumAlgebra.vacExpVal","page":"Interface","title":"QuantumAlgebra.vacExpVal","text":"vacExpVal(A::OpSum,S::OpSum=1)\n\nCalculate the vacuum expectation value 0S^dagger A S0, i.e., the expectation value ψAψ for the state defined by ψ= S0`.\n\n\n\n\n\n","category":"function"},{"location":"interface/#QuantumAlgebra.@boson_ops-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.@boson_ops","text":"@boson_ops name: define functions $name and $(name)dag for creating bosonic annihilation and creation operators with name name\n\n\n\n\n\n","category":"macro"},{"location":"interface/#QuantumAlgebra.@fermion_ops-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.@fermion_ops","text":"@fermion_ops name: define functions $name and $(name)dag for creating fermionic annihilation and creation operators with name name\n\n\n\n\n\n","category":"macro"},{"location":"interface/#QuantumAlgebra.@tlspm_ops-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.@tlspm_ops","text":"@tlspm_ops name: define functions $(name)m and $(name)p creating jump operators for a two-level system with name name.\n\n\n\n\n\n","category":"macro"},{"location":"interface/#QuantumAlgebra.@tlsxyz_ops-Tuple{Any}","page":"Interface","title":"QuantumAlgebra.@tlsxyz_ops","text":"@tlsxyz_ops name: define functions $(name)x, $(name)y, and $(name)z creating Pauli operators for a two-level system with name name.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumAlgebra","category":"page"},{"location":"#[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia","page":"Home","title":"QuantumAlgebra.jl - quantum operator algebra in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package does quantum operator algebra (i.e., algebra with non-commuting operators) in Julia. It defines an opinionated canonical form (normal ordering plus some additional rules) that all expressions are automatically transformed to, which fulfills some invariants that then allows easy use of the resulting expressions. It is recommended to use an interface that can display LaTeX formulas (e.g., Jupyter notebooks) for convenient output formatting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While there is some documentation, it is not always kept fully up to date, and it is recommended to look at the latest commit messages to get an idea about new features etc. You can also check out the example notebooks in the examples folder in the github repository. You can view them online directly with nbviewer and even try them out interactively with Binder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We define an abstract type that represents an operator, and some concrete subtypes to describe various operators. We have:","category":"page"},{"location":"","page":"Home","title":"Home","text":"scal(x) representing a scalar x\nparam(g,(i,j),state='n') representing a named scalar parameter g_ij. state can be 'r' for purely real parameters (invariant under complex conjugation), 'n' for not-conjugated values, and 'c' for a conjugated parameter g_ij^*.\na(i) and adag(i) representing a_i and a_i^, the annihilation and creation operators for bosonic mode i\nf(i) and fdag(i) representing f_i and f_i^, the annihilation and creation operators for fermionic mode i\nσ(a,i) representing the Pauli matrix σ_ai for two-level system (TLS) i, where a  x=1y=2z=3 is the type of Pauli matrix.\nOpProd(A,B) representing A B, i.e., the product of two operators\nOpSum(A,B) representing A + B, i.e., the sum of two operators\nOpSumAnalytical(i,A) or ∑(i,A) representing _i A, i.e., an analytical sum over an index (assumed to run over all possible values of i).\nExpVal(A) representing the expectation value A\nCorr(AB) representing the correlation AB_c = AB - AB, with corresponding extensions for products of more operators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All operations are defined in such a way that the finally created object is automatically transformed to \"canonical\" form, which is defined by the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operator sums are expanded fully, such that the final expression is always a sum of operator products. I.e., if we write (A + B)(C + D), we get AC + AD + BC + BD.\nOperator products are expressed in a well-defined \"canonical\" order. To achieve this canonical form, relevant commutators etc are used, so that an expression written as a single product can turn into a sum of expressions.\nat most one scalar prefactor (i.e., all prefactors collapsed into one)\nparameters ordered alphabetically (by string comparison)\nexpectation values A\nmany-body correlations AB_c\nbosonic operators in normal ordering (i.e., first creation, then annihilation operators), ordered by mode index\nfermionic operators in normal ordering (i.e., first creation, then annihilation operators), ordered by mode index\nTwo-level Pauli matrices, ordered by TLS mode index. At most one Pauli matrix per TLS\nOperator sums are ordered first by number of operators (both bare and within expectation values and correlations), and then with the same priority rules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some other useful functions that are implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"comm(A,B): calculates the commutator of arbitrary operators AB = AB - BA. This allows, e.g., to calculate Heisenberg equations of motion for the operators.\nascorr(x) takes an expression x=A B C + D E... and writes its expectation value in terms of single-body expectation values A, B, ..., and many-body correlations AB_c, ABC_c, etc. Currently, up to fourth-order correlations (i.e., products of four operators) are supported.\nAvac(A) and vacA(A) simplify operators by assuming they are applied to the vacuum from the left or right, respectively. To be precise, Avac(A) returns A such that A0 = A0, while vacA(A) does the same for 0A.\nvacExpVal(A,S=1) calculates the vacuum expectation value 0S^AS0, i.e., the expectation value ψAψ for the state defined by ψ=S0.","category":"page"}]
}
