var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"These functions (mostly) form the internal interface of the package, and should not be relevant to most users.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [QuantumAlgebra, QuantumAlgebra.OpConstructors]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumAlgebra","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :( using QuantumAlgebra; QuantumAlgebra.auto_normal_form(false); QuantumAlgebra.use_σxyz() )","category":"page"},{"location":"#[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia","page":"Home","title":"QuantumAlgebra.jl - quantum operator algebra in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package does quantum operator algebra (i.e., algebra with non-commuting operators) in Julia, supporting bosonic, fermionic, and two-level system operators, with arbitrary names and indices, as well as sums over any of the indices. It defines an opinionated canonical form (normal ordering plus some additional rules) to automatically simplify expressions. It is recommended to use an interface that can display LaTeX formulas (e.g., Jupyter notebooks) for convenient output formatting. While there is some documentation, it is not always kept fully up to date, and it is recommended to look at the latest commit messages to get an idea about new features etc. You can also check out the notebooks in the examples folder, which can be viewed online with nbviewer and tried out interactively with Binder.","category":"page"},{"location":"#Updates-in-v1.0.0","page":"Home","title":"Updates in v1.0.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a major revision with some breaking changes. The backend has been almost completely rewritten to make the code more efficient when dealing with large expressions, and the interface has been cleaned up in several places.","category":"page"},{"location":"#Important-changes:","page":"Home","title":"Important changes:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Canonical normal form is not automatically enforced by default. In order to transform expressions to normal form, use normal_form(x). Since automatic conversion to normal form can be convenient for interactive work, it can be enabled with QuantumAlgebra.auto_normal_form(true), or alternatively by setting the environment variable QUANTUMALGEBRA_AUTO_NORMAL_FORM to \"true\" (or any value that parse(Bool,value) parses as true) before using QuantumAlgebra.\nThe function to obtain expectation values is now expval(A) (instead of ExpVal), and expval_as_corrs(A) to express an expectation value through a correlator / cumulant expansion, e.g., AB = AB_c - A_c B_c, with corresponding extensions for products of more operators. Note that for a single operator, A_c = A, but we distinguish the two formally for clarity.\nThere is a new function julia_expression(A) that converts a QuantumAlgebra object to a julia expression, which helps in using QuantumAlgebra to programatically derive codes for numerical implementation. The object A cannot contain any \"bare\" operators, but only expectation values or correlators. See the documentation for more details.\nQuantumAlgebra expressions are now printed in pretty format in the terminal etc.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The basic functions to create QuantumAlgebra expressions (which are of type QuExpr) are","category":"page"},{"location":"","page":"Home","title":"Home","text":"a(inds...) and a'(inds...) for a and a^, the annihilation and creation operators for a bosonic mode.\nf(inds...) and f'(inds...) for f and f^, the annihilation and creation operators for a fermionic mode.\nσx(inds...), σy(inds...), σz(inds...) for the Pauli matrices σ^xyz for a two-level system (TLS).\nσp(inds...), σm(inds...) for excitation and deexcitation operators σ^ for a two-level system (TLS).\nIndices: All of these functions take an arbitrary number of indices as arguments, which can be either integers (1,2,...) or symbolic, where symbolic indices must be a single unicode character, with possibly an integer subindex:\njulia> using QuantumAlgebra\n\njulia> a()\na()\n\njulia> a'(:i)\na†(i)\n\njulia> f'(1,2,:i_9)\nf†(12i₉)\n\njulia> σx(:i_1, 1, :j, :k_2, :μ_2, :◔_1, :😄_121)\nσˣ(i₁1jk₂μ₂◔₁😄₁₂₁)\nYou can define your own bosonic/fermionic/two-level system operators with a set of macros:\n@boson_ops name defines new functions $name() and $(name)dag() for bosonic species name.\n@fermion_ops name defines new functions $name() and $(name)dag() for fermionic species name.\n@tlsxyz_ops name defines new functions $(name)x(), $(name)y() and $(name)z() for the Pauli matrices for two-level system species name.\n@tlspm_ops name defines new functions $(name)p() and $(name)m() for the two-level system excitation and deexcitation operators for species name.\nNote that for @boson_ops and @fermion_ops, deprecated $(name)dag() functions are defined for backward compatibility. These will be removed in a future version, as $(name)'() is now the preferred syntax for creating an adjoint.\njulia> @boson_ops b\n(b (QuExpr constructor), b† (QuExpr constructor))\n\njulia> b'(:k)*b(:i)\nb†(k) b(i)\nOperators with different names are assumed to belong to different \"species\" and always commute. For fermions, this is not always desired, since you might want to use different named operators to refer to different kinds of states for the same species (e.g., localized and itinerant electrons). This can be achieved with the macro @anticommuting_fermion_group, which creates several fermionic operators that mutually anticommute:\njulia> @anticommuting_fermion_group c d\n\njulia> normal_form(c()*d() + d()*c())\n0\nparam(name::Symbol,state='n',inds...) to create a named parameter. state must be one of 'r', 'n', or 'c' for purely real, non-conjugated complex, and conjugated complex parameters. More conveniently, parameters can be entered with string macros Pr\"name_inds...\" and Pc\"name_inds...\" for real and complex parameters:\njulia> Pr\"g_i,j_2,k\"\ng(ij₂k)\n\njulia> Pr\"g_i,j_2,k\" == param(:g,'r',:i,:j_2,:k)\ntrue\n\njulia> Pc\"α_3\" == param(:α,3)\ntrue\nArithmetic operations (*, +, -, ^, adjoint=') are supported (exponents must be nonnegative integers), with any Number types integrating automatically. Division by numbers is also supported.\njulia> 5*a'(:k)*f(3)*σx(3)\n5 a†(k) f(3) σˣ(3)\n\njulia> (5//3+4im) * a'(:k)*f(3)*σx(3) + 9.4\n9.4 + (5//3+4i) a†(k) f(3) σˣ(3)\n\njulia> (a(:i)*f(:k))'\nf†(k) a†(i)\nIf you need a bare number as a QuantumAlgebra expression, you can use x*one(QuExpr) (or one(A), where A is any QuExpr).\n∑(ind,A::QuExpr) to represent an analytic sum over index ind. Since summed indices have no semantic meaning, the index within the expression gets replaced by a special numbered sum index #ᵢ, with i=1,2,....\njulia> ∑(:i,a(:i))\n∑₁ a(#₁)\nnormal_form(A::QuExpr) converts an expression to a well-defined \"canonical\" order. To achieve this canonical form, relevant commutators etc are used, so an expression written as a single product can turn into a sum of expressions. The order is essentially normal ordering (creation before annihilation operators, with σˣʸᶻ in the middle), with some additional conventions to make the normal form (hopefully) unique. In some contexts (e.g., interactive work), it can be convenient to automatically transform all expressions to normal form. This can be enabled by calling QuantumAlgebra.auto_normal_form(true), or alternatively by setting the environment variable QUANTUMALGEBRA_AUTO_NORMAL_FORM to \"true\" (or any value that parse(Bool,value) parses as true) before using QuantumAlgebra.\njulia> normal_form(a(:i)*a'(:j))\nδ(ij)  + a†(j) a(i)\nexpval(A::QuExpr) to represent an expectation value.\njulia> expval(a'(:j)*a(:i))\n⟨a†(j) a(i)⟩\nexpval_as_corrs(A::QuExpr) to represent an expectation value through its correlators, i.e., a cumulant expansion.\njulia> expval_as_corrs(a'(:j)*a(:i))\n⟨a†(j)⟩c ⟨a(i)⟩c  + ⟨a†(j) a(i)⟩c\ncomm(A::QuExpr,B::QuExpr) to calculate the commutator AB = AB - BA.\njulia> comm(a(),a'())\n-a†() a() + a() a†()\n\njulia> normal_form(comm(a(),a'()))\n1\nAvac(A) and vacA(A) simplify operators by assuming they are applied to the vacuum from the left or right, respectively. To be precise, Avac(A) returns A such that A0 = A0, while vacA(A) does the same for 0A. These functions automatically apply normal_form to assure that the operators are simplified as much as possible. Note that \"vacuum\" for two-level systems is interpreted as the lower state, σ^z0 = -0.\njulia> Avac(a())\n0\n\njulia> Avac(a(:i)*a'(:j))\nδ(ij)\n\njulia> Avac(a()*a'()*a'())\n2 a†()\n\njulia> vacA(a()*a'()*a'())\n0\n\njulia> Avac(σx())\nσˣ()\n\njulia> Avac(σz())\n-1\nvacExpVal(A,S=1) calculates the vacuum expectation value 0S^AS0, i.e., the expectation value ψAψ for the state defined by ψ=S0. The result is guaranteed to not contain any operators.\njulia> vacExpVal(a'()*a())\n0\n\njulia> vacExpVal(a'()*a(), a'()^4/sqrt(factorial(4)))\n4.000000000000001\n\njulia> vacExpVal(a'()*a(), a'()^4/sqrt(factorial(big(4))))\n4\n\njulia> vacExpVal(σx())\n0\njulia_expression(A) to obtain a julia expression that can be used to automatically build codes implementing equations derived with QuantumAlgebra. Every expectation value or correlator is treated as a separate array. Daggers are represented as ᴴ, which are valid identifiers that can appear in the array names. Note that expectation values and correlators are not distinguished, so it is best to have all expressions use the same kind.\njulia> julia_expression(expval_as_corrs(a'(:j)*a(:i)))\n:(aᴴ[j] * a[i] + aᴴa[j, i])\nAlso note that expressions are always treated as arrays, even if they have no indices (which gives zero-dimensional arrays). If you are working with scalar quantities exclusively, it might be useful to clean up the resulting expression (e.g., use MacroTools to remove the []).\njulia> julia_expression(expval(a'()*a()*σx()))\n:(aᴴaσˣ[])\nBy default, two-level system operators are represented by the Pauli matrices σˣʸᶻ, and calling σp() and σm() will give results expressed through them:\njulia> σp()\n1//2 σˣ() + 1//2i σʸ()\n\njulia> σm()\n1//2 σˣ() - 1//2i σʸ()\nThis can be changed by calling QuantumAlgebra.use_σpm(true). In this mode, σ⁺ and σ⁻ are the \"fundamental\" operators, and all expressions are written in terms of them. Note that mixing conventions within the same expression is not supported, so it is suggested to set this flag once at the beginning of any calculation.\njulia> QuantumAlgebra.use_σpm(true)\n\njulia> σp()\nσ⁺()\n\njulia> σx()\nσ⁺() + σ⁻()\n\njulia> σz()\n-1 + 2 σ⁺() σ⁻()","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use QuantumAlgebra in academic work, we would appreciate a citation. See CITATION.bib for the relevant references.","category":"page"}]
}
