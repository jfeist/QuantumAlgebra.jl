<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ QuantumAlgebra.jl</title><meta name="title" content="Home ¬∑ QuantumAlgebra.jl"/><meta property="og:title" content="Home ¬∑ QuantumAlgebra.jl"/><meta property="twitter:title" content="Home ¬∑ QuantumAlgebra.jl"/><meta name="description" content="Documentation for QuantumAlgebra.jl."/><meta property="og:description" content="Documentation for QuantumAlgebra.jl."/><meta property="twitter:description" content="Documentation for QuantumAlgebra.jl."/><meta property="og:url" content="https://jfeist.github.io/QuantumAlgebra.jl/"/><meta property="twitter:url" content="https://jfeist.github.io/QuantumAlgebra.jl/"/><link rel="canonical" href="https://jfeist.github.io/QuantumAlgebra.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Release-notes-/-changelog"><span>Release notes / changelog</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Citing"><span>Citing</span></a></li></ul></li><li><a class="tocitem" href="interface/">Interface</a></li><li><a class="tocitem" href="release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jfeist/QuantumAlgebra.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia"><a class="docs-heading-anchor" href="#[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia"><a href="https://github.com/jfeist/QuantumAlgebra.jl">QuantumAlgebra.jl</a> - quantum operator algebra in Julia</a><a id="[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#[QuantumAlgebra.jl](https://github.com/jfeist/QuantumAlgebra.jl)-quantum-operator-algebra-in-Julia" title="Permalink"></a></h1><p>This package does quantum operator algebra (i.e., algebra with non-commuting operators) in Julia, supporting bosonic, fermionic, and two-level system operators, with arbitrary names and indices, as well as sums over any of the indices. It defines an opinionated canonical form (normal ordering plus some additional rules) to automatically simplify expressions. It is recommended to use an interface that can display LaTeX formulas (e.g., Jupyter notebooks) for convenient output formatting. </p><p>Starting from v1.4, QuantumAlgebra also interoperates with computer algebra systems (CAS) such as <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a> or <a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a> / <a href="https://github.com/jverzani/SymPyPythonCall.jl">SymPyPythonCall.jl</a>, as the &quot;scalar&quot; prefactors of each quantum term can be arbitrary expressions provided by these systems. While such expressions do not support symbolic indices in the same way as QuantumAlgebra, they provide much more flexibility in terms of the mathematical operations and powerful manipulation functions possible on the parameters.</p><p>Example jupyter notebooks are available in the <code>examples</code> folder and can be viewed online with <a href="https://nbviewer.jupyter.org/github/jfeist/QuantumAlgebra.jl/blob/main/examples/">nbviewer</a> and tried out interactively with <a href="https://mybinder.org/v2/gh/jfeist/QuantumAlgebra.jl/main?filepath=examples">Binder</a>.</p><h2 id="Release-notes-/-changelog"><a class="docs-heading-anchor" href="#Release-notes-/-changelog">Release notes / changelog</a><a id="Release-notes-/-changelog-1"></a><a class="docs-heading-anchor-permalink" href="#Release-notes-/-changelog" title="Permalink"></a></h2><p>Please see the <a href="release_notes/">release notes</a> for a summary of changes in each version.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The basic functions to create QuantumAlgebra expressions (which are of type <code>QuExpr</code>) are</p><ul><li><p><code>a(inds...)</code> and <code>a&#39;(inds...)</code> for <span>$a$</span> and <span>$a^{‚Ä†}$</span>, the annihilation and creation operators for a bosonic mode.</p></li><li><p><code>f(inds...)</code> and <code>f&#39;(inds...)</code> for <span>$f$</span> and <span>$f^{‚Ä†}$</span>, the annihilation and creation operators for a fermionic mode.</p></li><li><p><code>œÉx(inds...)</code>, <code>œÉy(inds...)</code>, <code>œÉz(inds...)</code> for the Pauli matrices <span>$œÉ^{x,y,z}$</span> for a two-level system (TLS).</p></li><li><p><code>œÉp(inds...)</code>, <code>œÉm(inds...)</code> for excitation and deexcitation operators <span>$œÉ^{¬±}$</span> for a two-level system (TLS).</p></li><li><p><strong>Indices</strong>: All of these functions take an arbitrary number of indices as arguments, which can be either integers (1,2,...) or symbolic, where symbolic indices must be a single unicode character, with possibly an integer subindex:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumAlgebra

julia&gt; a()
a()

julia&gt; a&#39;(:i)
a‚Ä†(i)

julia&gt; f&#39;(1,2,:i_9)
f‚Ä†(12i‚Çâ)

julia&gt; œÉx(:i_1, 1, :j, :k_2, :Œº_2, :‚óî_1, :üòÑ_121)
œÉÀ£(i‚ÇÅ1jk‚ÇÇŒº‚ÇÇ‚óî‚ÇÅüòÑ‚ÇÅ‚ÇÇ‚ÇÅ)</code></pre></li><li><p>You can define your own bosonic/fermionic/two-level system operators with a set of macros:</p><ul><li><code>@boson_ops name</code> defines new functions <code>$name()</code> and <code>$(name)dag()</code> for bosonic species <code>name</code>.</li><li><code>@fermion_ops name</code> defines new functions <code>$name()</code> and <code>$(name)dag()</code> for fermionic species <code>name</code>.</li><li><code>@tlsxyz_ops name</code> defines new functions <code>$(name)x()</code>, <code>$(name)y()</code> and <code>$(name)z()</code> for the Pauli matrices for two-level system species <code>name</code>.</li><li><code>@tlspm_ops name</code> defines new functions <code>$(name)p()</code> and <code>$(name)m()</code> for the two-level system excitation and deexcitation operators for species <code>name</code>.</li></ul><p>Note that for <code>@boson_ops</code> and <code>@fermion_ops</code>, deprecated <code>$(name)dag()</code> functions are defined for backward compatibility. These will be removed in a future version, as <code>$(name)&#39;()</code> is now the preferred syntax for creating an adjoint.</p><pre><code class="language-julia-repl hljs">julia&gt; @boson_ops b
(b (QuExpr constructor), b‚Ä† (QuExpr constructor))

julia&gt; b&#39;(:k)*b(:i)
b‚Ä†(k) b(i)</code></pre><p>Operators with different names are assumed to belong to different &quot;species&quot; and always commute. For fermions, this is not always desired, since you might want to use different named operators to refer to different kinds of states for the same species (e.g., localized and itinerant electrons). This can be achieved with the macro <code>@anticommuting_fermion_group</code>, which creates several fermionic operators that mutually anticommute:</p><pre><code class="language-julia-repl hljs">julia&gt; @anticommuting_fermion_group c d

julia&gt; normal_form(c()*d() + d()*c())
0</code></pre></li><li><p><code>param(name::Symbol,state=&#39;n&#39;,inds...)</code> to create a named parameter. <code>state</code> must be one of <code>&#39;r&#39;</code>, <code>&#39;n&#39;</code>, or <code>&#39;c&#39;</code> for purely real, non-conjugated complex, and conjugated complex parameters. More conveniently, parameters can be entered with string macros <code>Pr&quot;name_inds...&quot;</code> and <code>Pc&quot;name_inds...&quot;</code> for real and complex parameters:</p><pre><code class="language-julia-repl hljs">julia&gt; Pr&quot;g_i,j_2,k&quot;
g(ij‚ÇÇk)

julia&gt; Pr&quot;g_i,j_2,k&quot; == param(:g,&#39;r&#39;,:i,:j_2,:k)
true

julia&gt; Pc&quot;Œ±_3&quot; == param(:Œ±,3)
true</code></pre></li><li><p>Arithmetic operations (<code>*</code>, <code>+</code>, <code>-</code>, <code>^</code>, <code>adjoint</code>=<code>&#39;</code>) are supported (exponents must be nonnegative integers), with any <code>Number</code> types integrating automatically. Division by numbers is also supported.</p><pre><code class="language-julia-repl hljs">julia&gt; 5*a&#39;(:k)*f(3)*œÉx(3)
5 a‚Ä†(k) f(3) œÉÀ£(3)

julia&gt; (5//3+4im) * a&#39;(:k)*f(3)*œÉx(3) + 9.4
9.4 + (5//3+4i) a‚Ä†(k) f(3) œÉÀ£(3)

julia&gt; (a(:i)*f(:k))&#39;
f‚Ä†(k) a‚Ä†(i)</code></pre><p>If you need a bare number as a QuantumAlgebra expression, you can use <code>x*one(QuExpr)</code> (or <code>one(A)</code>, where <code>A</code> is any <code>QuExpr</code>).</p></li><li><p><code>‚àë(ind,A::QuExpr)</code> to represent an analytic sum over index <code>ind</code>. Since summed indices have no semantic meaning, the index within the expression gets replaced by a special numbered sum index <code>#·µ¢</code>, with <code>i=1,2,...</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ‚àë(:i,a(:i))
‚àë‚ÇÅ a(#‚ÇÅ)</code></pre></li><li><p><code>normal_form(A::QuExpr)</code> converts an expression to a well-defined &quot;canonical&quot; order. To achieve this canonical form, relevant commutators etc are used, so an expression written as a single product can turn into a sum of expressions. The order is essentially normal ordering (creation before annihilation operators, with œÉÀ£ ∏·∂ª in the middle), with some additional conventions to make the normal form (hopefully) unique. In some contexts (e.g., interactive work), it can be convenient to automatically transform all expressions to normal form. This can be enabled by calling <code>QuantumAlgebra.auto_normal_form(true)</code>. To make the setting permanent, call <code>QuantumAlgebra.auto_normal_form(true; set_preference=true)</code> or alternatively use <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a> directly, i.e., call <code>Preferences.set_preferences!(QuantumAlgebra,&quot;auto_normal_form&quot;=&gt;true/false)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; normal_form(a(:i)*a&#39;(:j))
Œ¥(ij)  + a‚Ä†(j) a(i)</code></pre></li><li><p><code>expval(A::QuExpr)</code> to represent an expectation value.</p><pre><code class="language-julia-repl hljs">julia&gt; expval(a&#39;(:j)*a(:i))
‚ü®a‚Ä†(j) a(i)‚ü©</code></pre></li><li><p><code>expval_as_corrs(A::QuExpr)</code> to represent an expectation value through its correlators, i.e., a cumulant expansion.</p><pre><code class="language-julia-repl hljs">julia&gt; expval_as_corrs(a&#39;(:j)*a(:i))
‚ü®a‚Ä†(j)‚ü©c ‚ü®a(i)‚ü©c  + ‚ü®a‚Ä†(j) a(i)‚ü©c</code></pre></li><li><p><code>comm(A::QuExpr,B::QuExpr)</code> to calculate the commutator <span>$[A,B] = AB - BA$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; comm(a(),a&#39;())
-a‚Ä†() a() + a() a‚Ä†()

julia&gt; normal_form(comm(a(),a&#39;()))
1</code></pre></li><li><p><code>Avac(A)</code> and <code>vacA(A)</code> simplify operators by assuming they are applied to the vacuum from the left or right, respectively. To be precise, <code>Avac(A)</code> returns <span>$A&#39;$</span> such that <span>$A|0‚ü© = A&#39;|0‚ü©$</span>, while <code>vacA(A)</code> does the same for <span>$‚ü®0|A$</span>. These functions automatically apply <code>normal_form</code> to assure that the operators are simplified as much as possible. Note that &quot;vacuum&quot; for two-level systems is interpreted as the lower state, <span>$œÉ^{z}|0‚ü© = -|0‚ü©$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; Avac(a())
0

julia&gt; Avac(a(:i)*a&#39;(:j))
Œ¥(ij)

julia&gt; Avac(a()*a&#39;()*a&#39;())
2 a‚Ä†()

julia&gt; vacA(a()*a&#39;()*a&#39;())
0

julia&gt; Avac(œÉx())
œÉÀ£()

julia&gt; Avac(œÉz())
-1</code></pre></li><li><p><code>vacExpVal(A,S=1)</code> calculates the vacuum expectation value <span>$‚ü®0|S^{‚Ä†}AS|0‚ü©$</span>, i.e., the expectation value <span>$‚ü®œà|A|œà‚ü©$</span> for the state defined by <span>$|œà‚ü©=S|0‚ü©$</span>. The result is guaranteed to not contain any operators.</p><pre><code class="language-julia-repl hljs">julia&gt; vacExpVal(a&#39;()*a())
0

julia&gt; vacExpVal(a&#39;()*a(), a&#39;()^4/sqrt(factorial(4)))
4

julia&gt; vacExpVal(a&#39;()*a(), a&#39;()^4/sqrt(factorial(big(4))))
4

julia&gt; vacExpVal(œÉx())
0</code></pre></li><li><p><code>julia_expression(A)</code> to obtain a julia expression that can be used to automatically build codes implementing equations derived with QuantumAlgebra. Every expectation value or correlator is treated as a separate array. Daggers are represented as <code>·¥¥</code>, which are valid identifiers that can appear in the array names. Note that expectation values and correlators are not distinguished, so it is best to have all expressions use the same kind.</p><pre><code class="language-julia-repl hljs">julia&gt; julia_expression(expval_as_corrs(a&#39;(:j)*a(:i)))
:(a·¥¥[j] * a[i] + a·¥¥a[j, i])</code></pre><p>Also note that expressions are always treated as arrays, even if they have no indices (which gives zero-dimensional arrays). If you are working with scalar quantities exclusively, it might be useful to clean up the resulting expression (e.g., use <code>MacroTools</code> to remove the <code>[]</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; julia_expression(expval(a&#39;()*a()*œÉx()))
:(a·¥¥aœÉÀ£[])</code></pre></li><li><p>By default, two-level system operators are represented by the Pauli matrices <span>$œÉ^{xyz}$</span>, and calling <code>œÉp()</code> and <code>œÉm()</code> will give results expressed through them:</p><pre><code class="language-julia-repl hljs">julia&gt; œÉp()
1//2 œÉÀ£() + 1//2i œÉ ∏()

julia&gt; œÉm()
1//2 œÉÀ£() - 1//2i œÉ ∏()</code></pre><p>This can be changed by calling <code>QuantumAlgebra.use_œÉpm(true; set_preference=true/false)</code> (where the value of <code>set_preference</code> determines whether this is stored permanently using Preferences.jl). In this mode, <span>$œÉ^{+}$</span> and <span>$œÉ^{-}$</span> are the &quot;fundamental&quot; operators, and all expressions are written in terms of them. Note that mixing conventions within the same expression is not supported, so it is suggested to set this flag once at the beginning of any calculation.</p><pre><code class="language-julia-repl hljs">julia&gt; QuantumAlgebra.use_œÉpm(true)

julia&gt; œÉp()
œÉ‚Å∫()

julia&gt; œÉx()
œÉ‚Å∫() + œÉ‚Åª()

julia&gt; œÉz()
-1 + 2 œÉ‚Å∫() œÉ‚Åª()</code></pre></li></ul><h3 id="Preferences"><a class="docs-heading-anchor" href="#Preferences">Preferences</a><a id="Preferences-1"></a><a class="docs-heading-anchor-permalink" href="#Preferences" title="Permalink"></a></h3><p>Several preferences changing the behavior of QuantumAlgebra can be set permanently (this uses <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>):</p><ul><li><code>&quot;define_default_ops&quot;</code>: if this is set to <code>false</code> (default is <code>true</code>), the &quot;default&quot; operators <code>a, adag, f, fdag, œÉx, œÉy, œÉz, œÉp, œÉm</code> are not defined upon import. Note that changing this value requires restarting the Julia session to take effect. The setting can be changed with <code>QuantumAlgebra.set_define_default_ops(true/false)</code> (which will inform you whether a restart is required) or with <code>Preferences.set_preferences!(QuantumAlgebra,&quot;define_default_ops&quot;=&gt;true/false).</code></li><li><code>&quot;auto_normal_form&quot;</code>: Choose whether all expressions are automatically converted to normal form upon creation. The default is <code>false</code>. It can be changed for a single session with <code>QuantumAlgebra.auto_normal_form(true/false)</code>, and can be made permanent with <code>QuantumAlgebra.auto_normal_form(true/false; set_preference=true)</code> or with <code>Preferences.set_preferences!(QuantumAlgebra,&quot;auto_normal_form&quot;=&gt;true/false)</code>. Note that this could previously be set by defining an environment variable <code>&quot;QUANTUMALGEBRA_AUTO_NORMAL_FORM&quot;</code>, but this usage has been deprecated and will be removed in a future version.</li><li><code>&quot;use_œÉpm&quot;</code>: Choose whether for two-level systems, the &quot;basic&quot; operators are excitation/deexcitation operators <span>$œÉ^{¬±}$</span> or the Pauli matrices `<span>$œÉ^{xyz}$</span>. This can be changed in a single session by calling <code>QuantumAlgebra.use_œÉpm(true/false)</code>, and can be made permanent with <code>QuantumAlgebra.use_œÉpm(true/false; set_preference=true)</code> or with <code>Preferences.set_preferences!(QuantumAlgebra,&quot;use_œÉpm&quot;=&gt;true/false)</code>.</li></ul><h2 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h2><p>If you use QuantumAlgebra in academic work, we would appreciate a citation. See <a href="https://github.com/jfeist/QuantumAlgebra.jl/blob/main/CITATION.bib"><code>CITATION.bib</code></a> for the relevant references.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="interface/">Interface ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 29 June 2024 15:50">Saturday 29 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
